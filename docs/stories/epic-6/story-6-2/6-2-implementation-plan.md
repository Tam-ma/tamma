# Story 6-2: Vector Database Integration - Implementation Plan

## Overview

This document outlines the detailed implementation plan for integrating vector database capabilities into the Tamma platform. The vector database will serve as the storage and retrieval backend for code embeddings generated by the Codebase Indexer (Story 6-1) and consumed by the RAG Pipeline (Story 6-3).

## Package Location

### Primary Package: `@tamma/intelligence`

The vector database integration will be implemented in the `packages/intelligence` package, which is designated for context and knowledge management capabilities.

**Rationale:**
- The `@tamma/intelligence` package already has dependencies on `@tamma/shared`, `@tamma/providers`, and `@tamma/observability`
- This aligns with Epic 6's focus on context and knowledge management
- Keeps vector store abstraction close to other RAG/indexing components

### Package Structure

```
packages/intelligence/
├── src/
│   ├── index.ts                          # Package exports
│   ├── vector-store/
│   │   ├── index.ts                      # Vector store exports
│   │   ├── interfaces.ts                 # Core interfaces & types
│   │   ├── factory.ts                    # Provider factory
│   │   ├── base-vector-store.ts          # Abstract base class
│   │   ├── providers/
│   │   │   ├── index.ts                  # Provider exports
│   │   │   ├── chromadb.ts               # ChromaDB adapter
│   │   │   ├── pgvector.ts               # pgvector adapter
│   │   │   ├── pinecone.ts               # Pinecone adapter (future)
│   │   │   ├── qdrant.ts                 # Qdrant adapter (future)
│   │   │   └── weaviate.ts               # Weaviate adapter (future)
│   │   ├── cache/
│   │   │   ├── index.ts                  # Cache exports
│   │   │   └── query-cache.ts            # Query result caching
│   │   ├── utils/
│   │   │   ├── index.ts                  # Utility exports
│   │   │   ├── metadata-filter.ts        # Filter parsing/building
│   │   │   └── distance-metrics.ts       # Score conversions
│   │   └── __tests__/
│   │       ├── interfaces.test.ts
│   │       ├── chromadb.test.ts
│   │       ├── pgvector.test.ts
│   │       ├── query-cache.test.ts
│   │       └── integration/
│   │           ├── chromadb.integration.test.ts
│   │           └── pgvector.integration.test.ts
│   └── ...
├── package.json
└── tsconfig.json
```

---

## Files to Create/Modify

### New Files

| File Path | Description |
|-----------|-------------|
| `src/vector-store/index.ts` | Main exports for vector store module |
| `src/vector-store/interfaces.ts` | Core interfaces: `IVectorStore`, `VectorDocument`, `SearchQuery`, etc. |
| `src/vector-store/factory.ts` | `VectorStoreFactory` for creating provider instances |
| `src/vector-store/base-vector-store.ts` | `BaseVectorStore` abstract class with common functionality |
| `src/vector-store/providers/index.ts` | Provider exports |
| `src/vector-store/providers/chromadb.ts` | `ChromaDBVectorStore` implementation |
| `src/vector-store/providers/pgvector.ts` | `PgVectorStore` implementation |
| `src/vector-store/cache/index.ts` | Cache exports |
| `src/vector-store/cache/query-cache.ts` | `QueryCache` for result caching |
| `src/vector-store/utils/index.ts` | Utility exports |
| `src/vector-store/utils/metadata-filter.ts` | Filter building utilities |
| `src/vector-store/utils/distance-metrics.ts` | Score conversion utilities |

### Files to Modify

| File Path | Changes |
|-----------|---------|
| `src/index.ts` | Add exports for vector store module |
| `package.json` | Add dependencies: `chromadb`, `pg`, optional peer deps |

---

## Interfaces and Types

### Core Interfaces

```typescript
// src/vector-store/interfaces.ts

import type { ILogger } from '@tamma/shared/contracts';

// === Configuration ===

export type VectorStoreProvider = 'chromadb' | 'pgvector' | 'pinecone' | 'qdrant' | 'weaviate';

export type DistanceMetric = 'cosine' | 'euclidean' | 'dot_product';

export interface VectorStoreConfig {
  provider: VectorStoreProvider;
  dimensions: number;
  distanceMetric: DistanceMetric;
  logger?: ILogger;

  // Provider-specific configs
  chromadb?: ChromaDBConfig;
  pgvector?: PgVectorConfig;
  pinecone?: PineconeConfig;
  qdrant?: QdrantConfig;
  weaviate?: WeaviateConfig;

  // Caching
  cache?: {
    enabled: boolean;
    ttlMs: number;
    maxEntries: number;
  };
}

export interface ChromaDBConfig {
  persistPath: string;
  anonymizedTelemetry?: boolean;
}

export interface PgVectorConfig {
  connectionString: string;
  poolSize?: number;
  schema?: string;
}

export interface PineconeConfig {
  apiKey: string;
  environment: string;
  indexName: string;
}

export interface QdrantConfig {
  url: string;
  apiKey?: string;
}

export interface WeaviateConfig {
  scheme: 'http' | 'https';
  host: string;
  apiKey?: string;
}

// === Health & Status ===

export interface HealthStatus {
  healthy: boolean;
  provider: VectorStoreProvider;
  latencyMs: number;
  details?: Record<string, unknown>;
  error?: string;
}

export interface CollectionStats {
  name: string;
  documentCount: number;
  dimensions: number;
  indexSize?: number;
  createdAt?: Date;
  updatedAt?: Date;
}

export interface CollectionOptions {
  dimensions?: number;
  distanceMetric?: DistanceMetric;
  metadata?: Record<string, unknown>;
}

// === Documents ===

export interface VectorDocument {
  id: string;
  embedding: number[];
  content: string;
  metadata: VectorMetadata;
}

export interface VectorMetadata {
  filePath?: string;
  language?: string;
  chunkType?: 'function' | 'class' | 'module' | 'block';
  name?: string;
  startLine?: number;
  endLine?: number;
  parentScope?: string;
  imports?: string[];
  exports?: string[];
  docstring?: string;
  hash?: string;
  indexedAt?: string;
  [key: string]: unknown;
}

// === Search ===

export interface SearchQuery {
  embedding: number[];
  topK: number;
  scoreThreshold?: number;
  filter?: MetadataFilter;
  includeMetadata?: boolean;
  includeContent?: boolean;
  includeEmbedding?: boolean;
}

export interface HybridSearchQuery extends SearchQuery {
  text: string;
  alpha?: number;  // 0 = keyword only, 1 = vector only, default 0.5
}

export interface SearchResult {
  id: string;
  score: number;
  content?: string;
  metadata?: VectorMetadata;
  embedding?: number[];
}

// === Metadata Filtering ===

export interface MetadataFilter {
  where?: Record<string, unknown>;           // Exact match
  whereIn?: Record<string, unknown[]>;       // In list
  whereNotIn?: Record<string, unknown[]>;    // Not in list
  whereGt?: Record<string, number>;          // Greater than
  whereGte?: Record<string, number>;         // Greater than or equal
  whereLt?: Record<string, number>;          // Less than
  whereLte?: Record<string, number>;         // Less than or equal
  whereContains?: Record<string, string>;    // String contains
  and?: MetadataFilter[];                    // AND conditions
  or?: MetadataFilter[];                     // OR conditions
}

// === Main Interface ===

export interface IVectorStore {
  // Lifecycle
  initialize(): Promise<void>;
  dispose(): Promise<void>;
  healthCheck(): Promise<HealthStatus>;

  // Collection management
  createCollection(name: string, options?: CollectionOptions): Promise<void>;
  deleteCollection(name: string): Promise<void>;
  listCollections(): Promise<string[]>;
  getCollectionStats(name: string): Promise<CollectionStats>;
  collectionExists(name: string): Promise<boolean>;

  // Document operations
  upsert(collection: string, documents: VectorDocument[]): Promise<void>;
  delete(collection: string, ids: string[]): Promise<void>;
  get(collection: string, ids: string[]): Promise<VectorDocument[]>;
  count(collection: string, filter?: MetadataFilter): Promise<number>;

  // Search operations
  search(collection: string, query: SearchQuery): Promise<SearchResult[]>;
  hybridSearch(collection: string, query: HybridSearchQuery): Promise<SearchResult[]>;

  // Maintenance
  optimize(collection: string): Promise<void>;
  vacuum(collection: string): Promise<void>;
}

// === Factory Interface ===

export interface IVectorStoreFactory {
  create(config: VectorStoreConfig): IVectorStore;
  getSupportedProviders(): VectorStoreProvider[];
}
```

### Cache Interface

```typescript
// src/vector-store/cache/query-cache.ts

export interface CacheEntry<T> {
  value: T;
  expiresAt: number;
  hitCount: number;
}

export interface CacheConfig {
  ttlMs: number;
  maxEntries: number;
}

export interface IQueryCache {
  get(key: string): SearchResult[] | undefined;
  set(key: string, results: SearchResult[]): void;
  invalidate(pattern?: string): void;
  getStats(): CacheStats;
}

export interface CacheStats {
  entries: number;
  hits: number;
  misses: number;
  hitRate: number;
  memoryUsageBytes: number;
}
```

---

## Implementation Phases

### Phase 1: Core Infrastructure (Days 1-3)

**Goals:** Establish the foundational interfaces, types, and base classes.

**Tasks:**

1. **Create interface definitions** (`interfaces.ts`)
   - Define all core interfaces as specified above
   - Add comprehensive JSDoc documentation
   - Export from module index

2. **Implement base vector store** (`base-vector-store.ts`)
   - Abstract class with common functionality
   - Logging integration with `@tamma/observability`
   - Metrics collection stubs
   - Input validation helpers

3. **Create factory pattern** (`factory.ts`)
   - Provider registration mechanism
   - Configuration validation
   - Lazy initialization support

4. **Utility functions** (`utils/`)
   - Distance metric conversions (cosine distance to similarity, etc.)
   - Metadata filter validation and normalization
   - ID generation helpers

**Deliverables:**
- [ ] `interfaces.ts` with all type definitions
- [ ] `base-vector-store.ts` abstract class
- [ ] `factory.ts` with provider registry
- [ ] `utils/distance-metrics.ts`
- [ ] `utils/metadata-filter.ts`
- [ ] Unit tests for utilities

### Phase 2: ChromaDB Integration (Days 4-7)

**Goals:** Implement the default ChromaDB adapter for local/embedded usage.

**Tasks:**

1. **ChromaDB adapter implementation** (`providers/chromadb.ts`)
   - Install and configure `chromadb` npm package
   - Implement all `IVectorStore` methods
   - Handle embedded mode with persistent storage
   - Collection management with proper error handling

2. **Search implementation**
   - Similarity search with k-NN
   - Score threshold filtering
   - Metadata filtering translation to ChromaDB format

3. **Hybrid search support**
   - Integrate with ChromaDB's built-in hybrid search if available
   - Or implement client-side fusion with BM25

4. **Connection management**
   - Connection pooling (if applicable)
   - Reconnection logic
   - Health check implementation

**Deliverables:**
- [ ] `providers/chromadb.ts` full implementation
- [ ] Unit tests with mocked ChromaDB client
- [ ] Integration tests with real ChromaDB instance
- [ ] Documentation for ChromaDB setup

### Phase 3: pgvector Integration (Days 8-11)

**Goals:** Implement PostgreSQL pgvector adapter for production deployments.

**Tasks:**

1. **pgvector adapter implementation** (`providers/pgvector.ts`)
   - Use `pg` package for PostgreSQL connection
   - Implement SQL-based vector operations
   - HNSW index creation and management
   - Transaction support

2. **Table/collection management**
   - Dynamic table creation with proper schema
   - Index creation with configurable parameters (m, ef_construction)
   - Migration utilities

3. **Query building**
   - Safe SQL query construction (prevent SQL injection)
   - Metadata JSONB filtering translation
   - Parameterized queries

4. **Performance optimizations**
   - Connection pooling with `pg-pool`
   - Batch insert optimization
   - Query plan analysis

**Deliverables:**
- [ ] `providers/pgvector.ts` full implementation
- [ ] SQL migration scripts
- [ ] Unit tests with mocked pg client
- [ ] Integration tests with real PostgreSQL + pgvector
- [ ] Documentation for pgvector setup

### Phase 4: Query Caching (Days 12-13)

**Goals:** Implement query result caching for improved performance.

**Tasks:**

1. **Cache implementation** (`cache/query-cache.ts`)
   - LRU cache with TTL expiration
   - Cache key generation from query parameters
   - Memory usage tracking

2. **Cache integration**
   - Integrate cache into base vector store
   - Cache invalidation on upsert/delete
   - Configurable cache bypass

3. **Cache monitoring**
   - Hit/miss rate tracking
   - Memory usage metrics
   - Cache statistics API

**Deliverables:**
- [ ] `cache/query-cache.ts` implementation
- [ ] Integration into `BaseVectorStore`
- [ ] Unit tests for cache logic
- [ ] Performance benchmarks

### Phase 5: Monitoring & Metrics (Days 14-15)

**Goals:** Add comprehensive observability and monitoring.

**Tasks:**

1. **Metrics integration**
   - Query latency histograms
   - Operation counters (search, upsert, delete)
   - Error rate tracking
   - Index size monitoring

2. **Health checks**
   - Provider-specific health checks
   - Connection pool status
   - Index health verification

3. **Structured logging**
   - Operation logging with context
   - Error logging with stack traces
   - Slow query logging

**Deliverables:**
- [ ] Metrics collection via `@tamma/observability`
- [ ] Health check endpoints
- [ ] Logging integration
- [ ] Grafana dashboard definitions (optional)

### Phase 6: Cloud Providers - Stubs (Days 16-17)

**Goals:** Create stub implementations for future cloud providers.

**Tasks:**

1. **Pinecone stub** (`providers/pinecone.ts`)
2. **Qdrant stub** (`providers/qdrant.ts`)
3. **Weaviate stub** (`providers/weaviate.ts`)

Each stub should:
- Implement `IVectorStore` interface
- Throw `NotImplementedError` with clear message
- Include configuration validation
- Document required setup steps

**Deliverables:**
- [ ] Stub implementations for all cloud providers
- [ ] Configuration schemas
- [ ] Documentation for future implementation

---

## Dependencies

### Runtime Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| `chromadb` | `^1.8.x` | ChromaDB client for embedded/client mode |
| `pg` | `^8.x` | PostgreSQL client |
| `lru-cache` | `^10.x` | LRU cache implementation |

### Peer Dependencies (Optional)

| Package | Version | Purpose |
|---------|---------|---------|
| `@pinecone-database/pinecone` | `^2.x` | Pinecone client (future) |
| `@qdrant/qdrant-js` | `^1.x` | Qdrant client (future) |
| `weaviate-ts-client` | `^2.x` | Weaviate client (future) |

### Dev Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| `@testcontainers/postgresql` | `^10.x` | PostgreSQL container for integration tests |
| `vitest` | `^1.x` | Test framework |

### Internal Dependencies

| Package | Purpose |
|---------|---------|
| `@tamma/shared` | Shared types, contracts, utilities |
| `@tamma/observability` | Logging, metrics, tracing |

### Upstream Dependencies (Story Dependencies)

| Story | Dependency Type | Description |
|-------|-----------------|-------------|
| Story 6-1: Codebase Indexer | Consumer | Provides embeddings to store |
| Story 6-3: RAG Pipeline | Consumer | Queries vector store for retrieval |

---

## Testing Strategy

### Unit Tests

**Coverage Target:** 90%+

```typescript
// Example test structure

describe('ChromaDBVectorStore', () => {
  describe('initialize', () => {
    it('should initialize with valid config', async () => {});
    it('should throw on invalid persist path', async () => {});
  });

  describe('createCollection', () => {
    it('should create collection with defaults', async () => {});
    it('should create collection with custom dimensions', async () => {});
    it('should throw if collection already exists', async () => {});
  });

  describe('upsert', () => {
    it('should insert new documents', async () => {});
    it('should update existing documents', async () => {});
    it('should handle batch of 1000 documents', async () => {});
    it('should validate embedding dimensions', async () => {});
  });

  describe('search', () => {
    it('should return top-k results', async () => {});
    it('should filter by score threshold', async () => {});
    it('should apply metadata filters', async () => {});
    it('should handle empty collection', async () => {});
  });

  describe('hybridSearch', () => {
    it('should combine vector and keyword search', async () => {});
    it('should respect alpha weighting', async () => {});
  });
});
```

### Integration Tests

**Test Scenarios:**

1. **End-to-end flow**
   - Create collection
   - Insert 1000 documents
   - Search and verify results
   - Delete and verify removal

2. **Large dataset performance**
   - Insert 100k vectors
   - Measure search latency
   - Verify under 50ms threshold

3. **Concurrent access**
   - Parallel searches
   - Parallel upserts
   - Mixed read/write operations

4. **Recovery scenarios**
   - Restart after insert
   - Verify persistence
   - Index corruption handling

### Performance Benchmarks

| Metric | Target | Test Method |
|--------|--------|-------------|
| Insert throughput | > 1000 vectors/sec | Batch insert 10k vectors |
| Search latency (p50) | < 20ms | 1000 searches on 100k index |
| Search latency (p95) | < 50ms | 1000 searches on 100k index |
| Search latency (p99) | < 100ms | 1000 searches on 100k index |
| Memory usage | < 500MB per 100k vectors | Monitor during load test |

### Test Data

Create fixture data generator:

```typescript
// test/fixtures/vector-data.ts

export function generateTestDocuments(count: number, dimensions: number = 1536): VectorDocument[] {
  return Array.from({ length: count }, (_, i) => ({
    id: `doc-${i}`,
    embedding: generateRandomEmbedding(dimensions),
    content: `Test content for document ${i}`,
    metadata: {
      filePath: `src/file-${i % 100}.ts`,
      language: 'typescript',
      chunkType: 'function',
      name: `function_${i}`,
      startLine: i * 10,
      endLine: i * 10 + 20,
    },
  }));
}

function generateRandomEmbedding(dimensions: number): number[] {
  const embedding = Array.from({ length: dimensions }, () => Math.random() - 0.5);
  // Normalize to unit vector
  const norm = Math.sqrt(embedding.reduce((sum, x) => sum + x * x, 0));
  return embedding.map(x => x / norm);
}
```

---

## Configuration

### Environment Variables

```bash
# ChromaDB
CHROMA_PERSIST_PATH=./data/chroma
CHROMA_TELEMETRY=false

# pgvector
PGVECTOR_CONNECTION_STRING=postgresql://user:pass@localhost:5432/tamma
PGVECTOR_POOL_SIZE=10
PGVECTOR_SCHEMA=public

# Pinecone (future)
PINECONE_API_KEY=your-api-key
PINECONE_ENVIRONMENT=us-east-1
PINECONE_INDEX_NAME=tamma-codebase

# Qdrant (future)
QDRANT_URL=http://localhost:6333
QDRANT_API_KEY=optional-api-key

# Weaviate (future)
WEAVIATE_HOST=localhost:8080
WEAVIATE_SCHEME=http
WEAVIATE_API_KEY=optional-api-key
```

### YAML Configuration

```yaml
# config/vector-store.yaml

vector_store:
  provider: chromadb  # chromadb | pgvector | pinecone | qdrant | weaviate
  dimensions: 1536
  distance_metric: cosine  # cosine | euclidean | dot_product

  cache:
    enabled: true
    ttl_ms: 300000  # 5 minutes
    max_entries: 10000

  chromadb:
    persist_path: ${CHROMA_PERSIST_PATH:./data/chroma}
    anonymized_telemetry: false

  pgvector:
    connection_string: ${PGVECTOR_CONNECTION_STRING}
    pool_size: ${PGVECTOR_POOL_SIZE:10}
    schema: ${PGVECTOR_SCHEMA:public}
    index:
      type: hnsw  # hnsw | ivfflat
      m: 16
      ef_construction: 64

  pinecone:
    api_key: ${PINECONE_API_KEY}
    environment: ${PINECONE_ENVIRONMENT}
    index_name: ${PINECONE_INDEX_NAME}

  qdrant:
    url: ${QDRANT_URL}
    api_key: ${QDRANT_API_KEY}

  weaviate:
    scheme: ${WEAVIATE_SCHEME:http}
    host: ${WEAVIATE_HOST}
    api_key: ${WEAVIATE_API_KEY}

  # Default collection settings
  defaults:
    collection_name: codebase
    batch_size: 100
    search_top_k: 20
```

### TypeScript Configuration Type

```typescript
// Re-export from interfaces.ts for external use

import { VectorStoreConfig } from './interfaces';

export function loadVectorStoreConfig(path: string): VectorStoreConfig {
  // Load from YAML, validate, and return typed config
}

export function validateVectorStoreConfig(config: unknown): config is VectorStoreConfig {
  // JSON Schema validation
}
```

---

## Error Handling

### Custom Error Types

```typescript
// src/vector-store/errors.ts

export class VectorStoreError extends Error {
  constructor(
    message: string,
    public readonly code: VectorStoreErrorCode,
    public readonly provider: VectorStoreProvider,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'VectorStoreError';
  }
}

export enum VectorStoreErrorCode {
  // Connection errors
  CONNECTION_FAILED = 'CONNECTION_FAILED',
  CONNECTION_TIMEOUT = 'CONNECTION_TIMEOUT',
  CONNECTION_LOST = 'CONNECTION_LOST',

  // Collection errors
  COLLECTION_NOT_FOUND = 'COLLECTION_NOT_FOUND',
  COLLECTION_ALREADY_EXISTS = 'COLLECTION_ALREADY_EXISTS',

  // Document errors
  DOCUMENT_NOT_FOUND = 'DOCUMENT_NOT_FOUND',
  INVALID_EMBEDDING_DIMENSIONS = 'INVALID_EMBEDDING_DIMENSIONS',

  // Query errors
  INVALID_FILTER = 'INVALID_FILTER',
  QUERY_TIMEOUT = 'QUERY_TIMEOUT',

  // Provider errors
  PROVIDER_NOT_SUPPORTED = 'PROVIDER_NOT_SUPPORTED',
  PROVIDER_NOT_IMPLEMENTED = 'PROVIDER_NOT_IMPLEMENTED',

  // Configuration errors
  INVALID_CONFIG = 'INVALID_CONFIG',
  MISSING_CREDENTIALS = 'MISSING_CREDENTIALS',
}
```

---

## Migration Notes

### From No Vector Store

For new installations:
1. Choose provider (ChromaDB for development, pgvector for production)
2. Configure environment variables
3. Initialize on application startup
4. Create default collection

### Future: Provider Migration

To migrate between providers:
1. Export all documents from source provider
2. Initialize new provider
3. Import documents in batches
4. Verify document counts match
5. Update configuration to new provider
6. Deprecate old provider

---

## Success Criteria

### Functional Requirements

- [ ] All `IVectorStore` interface methods implemented for ChromaDB
- [ ] All `IVectorStore` interface methods implemented for pgvector
- [ ] Metadata filtering works correctly for all filter types
- [ ] Hybrid search produces meaningful results
- [ ] Collections can be created, listed, and deleted

### Performance Requirements

- [ ] Search latency p95 < 50ms for 100k vectors
- [ ] Insert throughput > 1000 docs/second
- [ ] Memory usage < 500MB per 100k vectors

### Quality Requirements

- [ ] Unit test coverage > 90%
- [ ] Integration tests pass for both providers
- [ ] No critical or high severity security vulnerabilities
- [ ] API documentation complete

### Operational Requirements

- [ ] Health check returns accurate status
- [ ] Metrics exposed for monitoring
- [ ] Errors logged with sufficient context
- [ ] Configuration validated on startup

---

## Timeline Summary

| Phase | Duration | Milestone |
|-------|----------|-----------|
| Phase 1: Core Infrastructure | Days 1-3 | Interfaces and base classes complete |
| Phase 2: ChromaDB Integration | Days 4-7 | ChromaDB adapter production-ready |
| Phase 3: pgvector Integration | Days 8-11 | pgvector adapter production-ready |
| Phase 4: Query Caching | Days 12-13 | Caching layer complete |
| Phase 5: Monitoring & Metrics | Days 14-15 | Full observability |
| Phase 6: Cloud Provider Stubs | Days 16-17 | Stubs for future providers |

**Total Estimated Duration:** 17 working days

---

## References

- [Story 6-2: Vector Database Integration](/docs/stories/epic-6/story-6-2/6-2-vector-database-integration.md)
- [Story 6-1: Codebase Indexer](/docs/stories/epic-6/story-6-1/6-1-codebase-indexer.md)
- [Story 6-3: RAG Pipeline](/docs/stories/epic-6/story-6-3/6-3-rag-pipeline.md)
- [Engine Architecture](/docs/architecture/engine-flow.md)
- [Epic 6: Context & Knowledge Management](/docs/stories/epic-6/README.md)
- [ChromaDB Documentation](https://docs.trychroma.com/)
- [pgvector Documentation](https://github.com/pgvector/pgvector)
